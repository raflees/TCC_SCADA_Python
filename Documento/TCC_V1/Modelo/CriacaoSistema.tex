\chapter{Desenvolvimento do Sistema Supervisório}

\section{Requisitos do Sistema}

Para a escolha da tecnologia empregada, foram levantados os seguintes requisitos do sistema:
\begin{itemize}
	\item Deve ser gratuito para o desenvolvimento, simples e de código aberto no intuito de permitir análise por partes de interessados e facilitar melhorias e expansões;
	\item Deve ser capaz de desenhar gráficos em tempo real, advindos de porta serial. Opcionalmente pode ser compatível com arquivos nos formatos .csv, .tsv, .xls, e .xlsx, ou permitir modelagem direta no \textit{software}, por funções de transferência
	\item O \textit{software} deve rodar no sistema operacional windows (mínimo Windows 7)
\end{itemize}

\section{Seleção das Tecnologias}

Pelo primeiro requisito, em relação à gratuidade da tecnologia, pensou-se primeiramente em utilizar plataformas abertas para sistemas supervisórios, como o ScadaBR ou a versão demo do Elipse E3. Já houveram trabalhos, inclusive, utilizando a primeira tecnologia \cite{Moraes2016}.

Como atestado em \citeonline{Moraes2016}, o ScadaBR é construído em um servidor web, utilizando geralmente o Apache TomCat (como servidor web). É um \emph{software} \emph{open source} e existem vários materiais \emph{online}, tanto escritos como em vídeo orientando interessados em como utilizá-lo. Porém, os protocolos de comunicação pré-configurados são Modbus (IP e Serial) e OPC. Para aplicações com arduino, o usuário teria que criar uma função que enviasse os dados ao sistema no formato correto.

Quanto à versão demo do Elipse E3, segundo \citeonline{Elipse2019}, permite somente até 20 tags de dados e a aplicação roda por um máximo de 2 horas, tendo que ser reiniciada manualmente após este período. Isto a torna uma ferramenta muito limitada. Adicionalmente, não se sabe as implicações legislativas em utilizar o \emph{software} para trabalhos acadêmicos, nem sua utilização contínua no âmbito da universidade, mesmo se tratando de uma versão de demonstração.

Por cumprir todos os requisitos, e por ser considerado um método mais facilmente escalável, em questão de tecnologias atuais, foi decidido construir um sistema SCADA em Python. Desta maneira, o código-fonte da aplicação seria aberto, compatível com diferentes sistemas operacionais, e este trabalho contribuiria na difusão da implementação de \textit{software} gratuitos e \textit{open source} no meio acadêmico. Além disto, Python é uma linguagem contemporânea, tendendo a acompanhar o avanço tecnológico. Desta forma, o sistema desenvolvido seria compatível com uma vasta gama de tecnologias modernas, como por exemplo, armazenamento em nuvem.

\subsection{Seleção das bibliotecas}

Como já mencionado, a linguagem Python possui inúmeras bibliotecas, para os mais variados fins. No decorrer da criação do sistema, foram utilizadas as seguintes bibliotecas no Quadro \ref{qdr_used_libs}.

\begin{quadro}
	\centering
	\caption{Bibliotecas Python utilizadas no desenvolvimento do supervisório didático}
	\begin{tabular}{|m{5em}|m{25em}|}
		\hline
		Biblioteca & Descrição \\
		\hline
		PyQt5 & Usada para a construção de GUIs, contém diversos objetos úteis como botões, caixas de texto e rótulos. Também trata do posicionamento e direção destes objeto nas janelas principal e periféricas \cite{pyqtdoc} \\
		\hline
		PyQtChart & Conjunto de conectores de python para a biblioteca Qt \\
		\hline
		matplotlib & Contém ferramentas que permitem o desenho e design de gráficos variados, inclusive com objetos backend que fazem uma ponte com GUIs construídas com PyQt5 \cite{hunter2007matplotlib} \\
		\hline
		numpy & Biblioteca que lida com operações matriciais e cálculos avançados, com muitas funcionalidades similares ao MatLab. Também é capaz de gerar números aleatórios, que são úteis no teste do programa \cite{harris2020array} \\
		\hline
		pyserial & Permite a conexão com dispositivos externos pela porta serial e contém funções de escrita e leitura desta porta \cite{pyserial} \\
		\hline
		python-control & Possibilita a criação de sistemas descritos em funções de transferência e espaço de estados, além de gerar a resposta simuladas para alguns formatos comuns de entradas, como degrau e impulso \cite{pythoncontrol} \\
		\hline
		pickle & Responsável pera serialização de objetos utilizados no código e armazenamento dos mesmos em um arquivo à parte. Lida também com a leitura e decodificação de objetos serializados \\
		\hline
	\end{tabular}
	\label{qdr_used_libs}
\end{quadro}

\section{A interface gráfica}

A biblioteca PyQt funciona como uma linguagem orientada a objetos. Assim, esta arquitetura foi adotada no desenvolvimento da ferramenta. Foi utilizado uma folha de \emph{script} que agrupasse a maior parte das classes implementadas, o form\_objects.py, e outro \emph{script} principal, main.py que inicia a execução do programa. Um terceiro \emph{script}, realtime\_objects.py, contempla objetos que rodam em tempo real e espera-se que futuros usuários também editem o código contido, por motivos explanados posteriormente neste documento. No Apêndice \ref{Chap:Apendice1} encontra-se um tutorial de utilização do supervisório.

No que concerne a interface gráfica do supervisório, imaginou-se um \emph{layout} simplista. A aplicação conteria uma área para apresentação de gráficos, uma lista das séries de dados incluídas no programa pelos diversos métodos possíveis, e uma área para incluir séries novas. Os detalhes destes Widgets são listados abaixo, e sua disposição mostradas na Figura \ref{img_gui_macro}:

\begin{itemize}
	\item \emph{PlotManager}: representaria uma área de rolagem (QScrollArea) que conteria várias representações gráficas das séries de dados salvos na aplicação, com uma pequena \emph{preview} destes dados, e botões para seu desenho, edição e exclusão da série.
	\item \emph{MainPlotArea}: utiliza um objeto \emph{FigureCanvas}, da lib matplotlib, para criação de um gráfico detalhado das séries selecionadas na lista de séries. O eixo y assumiria várias dimensões, a depender da variável representada, e o eixo x englobaria o tempo.
	\item \emph{DatasetConfig}: tem como Widget principal um seletor com abas (\emph{QTabWidget}), que permitiria a inclusão de séries de dados novas no programa, pelas fontes já mencionadas, sendo cada aba responsável pelas diferentes métodos (serial, arquivo, função de transferência, etc)
	\item \emph{SCADADialog}: se trata realmente de uma tela de supervisão, com uma área de gráficos atualizada em tempo real. Funciona somente quando os dados são importados por porta serial.
\end{itemize}

\begin{figure}[hbt]
	\centering
	\caption{Supervisório didático e seus objetos principais}
	\includegraphics[width=\textwidth]{GUI_macro}
	\label{img_gui_macro}
\end{figure}

Além dos Widgets supracitados, para simplificar o código e torná-lo mais prático, foi criado um objeto abstrato \emph{SeriesObject}. Ele armazena um agrupamento de série de dados que compartilham um mesmo eixo de tempo. Desta forma, foi mais fácil manipular as referências das séries pelo programa. Uma imagem contendo todos os objetos criados no desenvolvimento do programa, bem como suas relações e funções, encontra-se no Apêndice \ref{Chap:Apendice2}.

\section{\emph{Dataset Config}}

A principal função deste objeto é de interface da aplicação com outros dispositivos ou programas, com a finalidade de puxar séries de dados destas fontes. A segunda função é de formatar estas séries, atribuindo a elas um nome e um cabeçalho, além de definir que legenda aparece no gráfico principal quando ele for desenhado.

Na fase de idealização do \emph{software}, levantou-se possíveis meios para adicionar séries de dados novas no programa. Como se trata de um sistema supervisório, deve haver uma funcionalidade que permita o recebimento de dados externos, no mínimo por comunicação serial, bastante utilizada por controladores didáticos como Arduino e Raspberry Pi. Como adicionais,, seria útil também a importação de séries por arquivos \emph{.xls} ou \emph{.xlsx}. Por último, caso o usuário deseje utilizar funcionalidades não ofertadas pelo \textit{software} didático, ele pode escrever seu próprio script Python e levar os resultados para o programa.

Como o supervisório foi desenvolvido para a área didática da automação, ele deveria oferecer uma maneira simples de simular processos diversos e representar as simulações por gráficos, contrastando-as com o sistema real, proveniente do controlador. Logo, foi incluída biblioteca que simulasse as resposta de funções de transferência, por padrão a uma entrada degrau, e fornecidos os meios para que o usuário encadeie em série variadas funções, de parâmetros quaisquer, pelo objeto \emph{TransferFunctionConfig}.

Resumindo, existem quatro maneiras de importar ou gerar uma série de dados no \emph{software} desenvolvido:

\begin{enumerate}
	\item \textbf{Por arquivo}, nos formatos \emph{csv} (Comma Separated Values), \emph{tsv} (Tab Separated Values), \emph{xls} (antigo arquivo Excel), \emph{xlsx} (arquivo Excel);
	\item \textbf{Por função de transferência}, informando o numerador e denominador de cada função, criadas em série e submetidas a uma entrada do tipo degrau, de valor definido pelo usuário;
	\item \textbf{Por comunicação serial}, configurando alguns parâmetros (porta, baud rate e tempo para timeout), separando cada valor enviado pelo dispositivo por uma tabulação e linhas por quebras de linha;
	\item \textbf{Por script Python}, escrevendo um código python funcional e retornando os valores das séries na ordem correta (lista dos valores das séries, série de valores de tempo, lista de nomes das séries, nesta ordem)
\end{enumerate}

Caso não haja problemas na importação e as condições de formatação para cada método de entrada forem satisfeitas, o programa abrirá uma caixa diálogo (\emph{QtWidgets.QDialog}) idêntica à da Figura \ref{img_edit_series_dialog} com uma \textit{preview} dos dados e uma tabela com os valores numéricos. Através dele é possível editar cada valor separadamente, o nome da série e o cabeçalho.

\begin{figure}[hbt]
	\centering
	\caption{\emph{ModelSeriesDialog}: Caixa diálogo para edição dos eixos e título das séries}
	\includegraphics[width=\textwidth]{edit_series_dialog}
	\label{img_edit_series_dialog}
\end{figure}

Esta caixa diálogo contém um Widget frequentemente utilizado na aplicação: o \emph{FigureCanvas}, proveniente de um módulo da biblioteca matplotlib, que funciona como um plugin para o PyQt. Apesar dele não ser um Widget do PyQt, ele contém, se não todos, uma boa parte de seus módulos e é tratado como tal para fins de posicionamento, geometria e inclusão nos \textit{layouts} de tela. O \emph{FigureCanvas} faz uma interface com o objeto \emph{Figure}, responsável pela criação de gráficos de linhas, barras, etc, e permite que ele seja incluído numa GUI construída em PyQt.

O objeto \emph{Figure}, por sua vez, é bem similar ao objeto de mesmo nome no MATLab\textsuperscript{\tiny \textregistered}, aceitando métodos como \emph{plot()}, emph{add\_subplot()} e \emph{clear()}. Sua documentação completa, juntamente com a de outros objetos relevantes consta no site da biblioteca \href{https://matplotlib.org/}{matplotlib}. Quando embutido numa GUI por um \emph{FigureCanvas}, após o desenho de gráficos e de formatações gerais, o segundo deve chamar o método \emph{draw()} para que seja atualizada a imagem.

%\textcolor{red}{Devo Focar no algoritmo de cada tipo de importação??}

\section{\emph{PlotManager}}

Como consta na Figura \ref{img_gui_macro} o lado direito da aplicação, se encontra uma lista das séries carregadas. Dado o espaço limitado, faz-se necessária uma área de rolagem. Assim, foi criado um objeto \emph{GraphicPlotList} que implementa esta área ao herdar de \emph{QtWidgets.QScrollArea}.

Quando uma série nova é criada pelo \emph{DatasetConfig}, ela fica armazenada em um objeto \emph{SeriesObject}, que é representado graficamente na lista de séries \emph{GraphicPlotList} por um outro objeto \emph{GraphicPlotConfig} (Figura \ref{img_graphic_plot_config}).

\begin{figure}[hbt]
	\centering
	\caption{\emph{GraphicPlotConfig} não desenhado em \emph{MainPlotArea}}
	\includegraphics{graphic_plot_config}
	\label{img_graphic_plot_config}
\end{figure}

A principal função deste objeto é identificar pelo nome e fonte a série que contém, e coordenar quando esta série deve ser desenhada na área principal \emph{MainPlotArea}, além de permitir sua edição ou deleção. Contribuindo com a identificação dos dados, foi incluída uma visualização simples das séries, o que torna o visual estético. A cor de fundo do \emph{GraphicPlotConfig} alterna entre verde e vermelho, indicando se as séries contidas foram desenhadas ou não. Ao clicar no botão “Edit”, uma caixa diálogo idêntica à de incluir uma série nova aparece permitindo que o usuário edite seus valores, cabeçalho e nome.

Em PyQt, os objetos de uma GUI são “pintados” na tela por um objeto \emph{QtGui.QPainter}, de acordo com sua área, e paleta de cores. A primeira informação depende de alguns parâmetros, como o \textit{layout} no qual ele está inserido ou sua política de tamanho (QSizePolicy). Isto ocorre no método \emph{paintEvent(event)}, chamado automaticamente quando o objeto é reposicionado ou quando sua aparência deve ser atualizada (cada caractere novo digitado numa caixa de texto, por exemplo).

Essa dinâmica torna necessário que o método seja sobrecarregado quando o programador deseje customizar a aparência de um botão ou o seu plano de fundo. A desvantagem é que, por sobrecarregar o método que pinta o objeto na interface, o objeto deve ser repintado manualmente. No caso de um botão, por exemplo, no mínimo o método \emph{drawRectangle()} e \emph{drawText()} deve ser invocado. Assim, quanto mais detalhado for um objeto, mais complicado se torna alterar suas cores e formatos internos. Existem maneiras que contornam a necessidade de criar um novo objeto e sobrescrever o método \emph{paintEvent()}, utilizando as chamadas stylesheets. Porém, para este trabalho, julgou-se mais simples a primeira opção, pelo fato dos objetos customizados possuírem um design pouco complexo.

O objeto \emph{GraphicPlotConfig}, por alternar suas cores de fundo, teve seu evento de "pintura" sobrecarregado. Como sua tela de fundo é representada apenas por um retângulo, sua implementação não foi muito dificultosa.

\section{\emph{MainPlotArea}}

Se tratando de análises de sistemas, a visualização dos dados é essencial. No canto inferior esquerdo da GUI, existe uma área de gráficos, implementada por um objeto \emph{FigureCanvas} (Figura \ref{img_main_plot_area}. Abaixo dele, uma faixa de ferramentas (\emph{NavigationToolbar2QT}) permite que o usuário edite algumas propriedades do gráfico gerado, aproxime ou distancie a imagem e, principalmente, salve a figura em formato de imagem. Na lista de séries à direita, ao clicar no botão “Plot”, a série associada serão desenhadas no Canvas, com legenda.

\begin{figure}[htb]
	\centering
	\caption{\emph{MainPlotArea}}
	\includegraphics[width=0.8\textwidth]{main_plot_area}
	\label{img_main_plot_area}
\end{figure}

\section{\emph{SCADADialog}}

Um sistema supervisório, como o apresentado neste documento, monitora dados de controladores geralmente industriais em tempo real. Por se tratar de um \emph{software} didático, foi incluído no programa um suporte para futuras comunicações com um Arduíno ou qualquer outro microcontrolador ou até mesmo dispositivos que permitam comunicação serial. Assim, configurados os parâmetros de comunicação (\emph{baud rate}, nome da porta e tempo de timeout), o usuário pode visualizar graficamente dados enviados por um controlador em tempo real, desde que os mesmos estejam no formato esperado: tabulações para separar diferentes séries de dados e quebras de linhas para finalizar um registro.

Ao importar dados por fonte serial no \emph{DatasetConfig}, sugere-se sempre testar a comunicação antes de clicar no botão “Puxar dados”. quando o mesmo é clicado, uma caixa diálogo \emph{DialogHeader} é aberta, para que o usuário edite os nomes das variáveis recebidas via serial. A primeira série é sempre o tempo, e o dispositivo conectado \textbf{deve} obedecer esta ordem. Ao clicar em OK nesta caixa, a comunicação com a porta serial será iniciada e uma janela de monitoramento surgirá, caso não tenha ocorrido nenhum erro de comunicação.

%Vale a pena colocar referencia nestes trechos?
O código da comunicação com periféricos implementa duas \emph{threads} da biblioteca nativa \emph{\_thread} do Python. Segundo \citeonline{threads}, threads são trechos de código que rodam simultaneamente em um mesmo processo pai. Por conta disso, ao utilizar esta estrutura, alguns cuidados devem ser tomados pelo programador, no que se refere a acesso compartilhado à memória. Como não há controle de execução de cada thread separadamente, bugs podem ocorrer caso mais de um processo acesse e modifique o mesmo objeto ou variável simultaneamente.

Para contornar este problema, existem algumas estruturas que controlam o acesso de memória em programas que implementam threads, como monitores e semáforos. O último é, talvez, o mais trivial. Um semáforo possui dois estados: aberto ou fechado. Quando uma thread toma controle de um objeto no código, o semáforo é fechado, impedindo que outras threads façam o mesmo, até que o objeto seja liberado e o semáforo reaberto. Para Python, existem bibliotecas que implementam estruturas de controle, como a \emph{asyncio}, porém, por ser uma estrutura simples e não utilizada mais que algumas vezes no código-fonte deste trabalho, uma variável booleana bastou.

Após a conexão bem sucedida com o dispositivo, o programa escreve uma mensagem na porta serial (“go”, por padrão) e inicia suas duas threads, uma para ler dados da porta, e outra para atualizar o Canvas da caixa diálogo \emph{SCADADialog}. Esta separação se fez necessária pois o método do Canvas que o atualiza (emph{draw()}) é considerado custoso, e poderia travar a aplicação se fosse executada repetidas vezes. Outro motivo para implementação das threads é exemplificar a estudantes do código uma implementação simples de paralelismo, o que pode ser bastante util e que não é abordadas nos cursos tradicionais de Engenharia (excetuando computação).

Cada uma das threads tem um tempo de repetição, que define a periodicidade que elas executam suas instruções. O padrão definido foi de 0,1 segundos para ler dados da porta serial, e 1 segundo para atualizar o gráfico com os valores lidos. Quando a leitura da porta ocorre, os valores são armazenados em uma lista compartilhada. Quando a rotina de atualização é chamada, os valores desta lista são movidos para outra, chamada \emph{plotted}, que por sua vez gera um gráfico, e o Canvas é atualizado. A manipulação de uma lista compartilhada justifica o emprego de um semáforo, pois uma \textit{thread} escreve nesta lista e outra a lê.

Como já mencionado, o programa espera que os dados recebidos sejam espaçados por tabulações, separando diferentes variáveis, e quebras de linhas, separando diferentes leituras ao longo do tempo de execução. O primeiro valor lido sempre é considerado o tempo, e deve vir do dispositivo conectado, pois o mesmo é quem dita o andamento do processo controlado. Caso o número de variáveis numa mesma linha lida seja diferente do configurado no objeto DatasetConfig, o programa considerará que houve um erro e toda a linha de dados será ignorada.

A figura \ref{img_esquema_serial} esquematiza a execução do código de monitoramento serial:

\begin{figure}[hbt]
	\centering
	\caption{Esquema de leitura serial no supervisório didático}
	\includegraphics{esquema_serial}
	\label{img_esquema_serial}
\end{figure}

Para que o programa possa ser de fato implementado em aulas, foram adicionadas duas funções que possibilitam de envio de dados ao dispositivo conectado a cada leitura da porta serial. Isto seria uma analogia a um controlador que atuasse num processo físico, medido por tal dispostivo. Desta forma, o último simularia o sistema em si, enquanto que parte do supervisório didático assumiria o papel de controlador. Devido à popularidade do microcontrolador Arduino, a implementação da rotina de controle dentro do \emph{software} foi projetada similarmente à sua programação. A rotina é feita em duas etapas, uma na função \emph{setup\_control}, chamada logo após uma conexão bem-sucedida com o dispisitivo, uma única vez, e outra na função \emph{loop\_control}, chamada logo após cada leitura da porta serial.

Numa aplicação de controle PID, por exemplo, a primeira função realizaria sua sintonia ou informaria à "planta" os parâmetros de seus processos, enquanto que a segunda função receberia do supervisório a última linha lida da porta, calcularia a resposta do controlador PID, e escreveria o resultado de volta. Obviamente, o dispositivo conectado deve ser programado para receber esta informação, o que requer certo conhecimento do usuário, tanto de Python como do dispositivo em si. Felizmente, códigos de exemplo se encontram disponíveis neste documento.

Durante o monitoramento e registro dos valores trazidos via serial, o gráfico irá atualizar numa janela de 20 segundos, contando do maior tempo registrado para trás. Isto se justifica no comportamento dinâmico da maioria dos sistemas, que atinge valores por vezes maiores que os estacionários. Esta medida impede que a escala do gráfico fique prejudicada, e variações pequenas relativas a um comportamento estacionário não sejam bem percebidas. O usuário pode, de todo modo, em tempo de execução clicar nos botões “Parar” e “Criar Série”, salvar as séries de dados lidas e desenha-as no objeto MainPlotArea, visualizando todo seu comportamento histórico.

\section{Salvamento Automático de Séries}

Durante a utilização do supervisório didático, espera-se que ajustes sejam feitos nas funções que simulam o controlador. Quando o script Pyhton é iniciado, uma cópia dele é criada e compilada, tornando impossível que alterações no script original em tempo de execução tenham influências no sistema. Por isso, o usuário tem que fechar o supervisório didático sempre que desejar alterar as funções \emph{setup\_control()} e \emph{loop\_control()}, o que resultaria na perda das séries já salvas pelo programa.

Para amenizar este problema, foi incluída uma funcionalidade de salvamento automático na aplicação. Uma das bibliotecas nativas do Python, o \emph{Pickle}, permite que um objeto ou variável do programa seja serializada em formato de arquivo, e salva em um diretório no computador. Isto ocorre através do comando \emph{pickle.dump()} Desta forma, o arquivo pode ser restaurado (\emph{pickle.load()}) e reincorporado ao código com os mesmos valores de atributos que possuía quando foi serializado.

Sempre que uma série é incluída, editada ou deletada, o arquivo "autosave.dat" é sobrescrito com a lista de séries da sessão (\emph{listSeries}). Em contrapartida, quando o objeto \emph{PlotManager} é inicializado, o arquivo "autosave.dat" é aberto e a lista de séries lá salva é restaurada.